/*
Yet Another MVC Game

Controllers recieve all input
Controllers have current 'primary child' that recieves any input not stopped by controller [think bubbles]


Engine:
- Battle Controller
-- MapController
-- UnitController

- Battle
-- Map
-- Units

idea:
each display area has 3 planes -- above, normal, below -- these planes nest amonst like kinds in z-index order, but anything on high is above anything on normal.
Implmenented with 3 display objects on root that move as one, but inhabit different z-indexes

*/



class Engine {




}


public final class ZPlane {
    public static const LOW:ZPlane = new ZPlane();
    public static const NORMAL:ZPlane = new ZPlane();
    public static const HIGH:ZPlane = new ZPlane();
}


class WrappedMovieClip extends MovieClip {
}

abstract class SpriteModel {
    // All coords are relative to parent object, they know nothing of the world beyond. Ideally can go negative, TBD.
    public function get x():int;
    public function get y()int;
    public function get z():int;
    public function get animationFrame():int;
    public function get currentAnimation():AnimatedClip
}


class TileList extends Array { } // Some sort of array?
class TileSet extends Set { }

class Map extends BaseModel {
    
}

class UnitMoveController extends BaseController {
    public function UnitMoveController(map:Map) {
    }

    public function getAllowableMoves(unit:Unit):TileSet {
    }

    public function routeToSquare(unit:Unit, tile:Tile):TileList {
    }
}



class Battle {
    public final var attacker:Unit;
    public final var defender:Unit;
    // TBD
}

class FightController extends BaseController {
    public function FightController(map:Map) {
    }

    public function getBattle(attacker:Unit, defender:Unit):Battle {

    }
}

class UnitController extends BaseController{

}

class MapController extends BaseController {

}


/*
Flows
*/

public interface ICond {
	public function check(callback:IFlow) {

	}
}


class LoopPlan extends FlowPlan {

	protected var _cond:Function;
	protected var _data:*;
	protected var _savedPlan:Array;

	// Re-runs the plan until cond(data) returns false
	public function LoopPlan(cond:Function) {
		super();
		_cond = cond;
	}

	public override function Execute(data:*):void {
		_savedPlan = _plan.slice();
		_data = data;
		super.execute(data);
	}

	public override function Complete():void {
		if _cond(_data) {
			_plan = _savedPlan;
			execute(_data);
		} else {
			super.Complete();
		}
	}
}



public interface IFlow {

	public function onComplete(callback):IFlow {
	}

	public function execute(data:*):void {
	}

}

class BaseFlow Implements IFlow {

	public function onComplete(f:Callback):void {
		addEventListener(Event.COMPLETE, f);
		return this;
	}

	public function Execute(data:*):void {
		trace("Default execute for " + getQualifiedClassName(this));
		Complete();
	}

	protected function Complete():void {
		dispatcEvent(Event.COMPLETE);
	}
}

class SyncFlow extends BaseBlow {
	protected var _callable:Function;
	public function SyncFlow(callable:Function) {
		_callable = callable;
	}
	public override function Execute(data:*) {
		_callable(data);
		Complete();
	}
}

class FlowPlan extends BaseFlow {

	protected var _plan:Array = new Array();
	protected var _running:Boolean = false;

	public static function Do(k:Class):FlowPlan {
		var fp:FlowPlan = new FlowPlan();
		fp.addStep(k);
		return fp;
	}

	public function While(cond:Function):FlowPlan {
		var plan:Array = _plan.slice();
		fp.addStep(new SyncFlow(function(data:*) {
					if (cond(data)) {
						_plan = plan.slice();
					}
				}));
	}

	protected function addStep(k:Class):void {
		if (_running) {
			throw new Error("Can't call addStep on a running FlowPlan");
		}
		_plan.push(k);
	}

	public function Then(k:Class):FlowPlan {
		addStep(k);
		return this;
	}

	public function Execute(data:*):void {
		if (_running) {
			throw new Error("Can't call Execute() on a running FlowPlan");
		}
		_running = true;
		_execute(data);
	}

	protected function _execute(data:*)void {
		if (_plan.length == 0) {
			Complete();
			return;
		}
		(new _plan.pop()).onComplete(function(evt:Event) { _execute(data); }).Execute(data);
	}
}


internal class BattleSetupFlow extends BaseFlow { }
internal class StartBattleFlow extends BaseFlow { }
internal class UnitTurnFlow extends BaseFlow { }
//class AfterUnitTurnFlow extends BaseFlow { }
internal class BattleResultsFlow extends BaseFlow { }
internal class CleanupBattleFlow extends BaseFlow { }

function battleIsOn(battleModel:BattleModel) {
	return false;
}

class BattleFlow {
	// Magic model injection?

	public function setupFlow() {
		var plan:FlowPlan = (FlowPlan.Do(showBattleView)
			.Then(BattleSetupFlow)
			.Then(StartBattleFlow)
			.Then(FlowPlan.While(battleIsOn)
				.Then(StartUnitTurn))
			.Then(BattleResultsFlow)
			.Then(CleanupBattleFlow));
	}
}

class UnitFlow {

	public function flowStart() {
		setCurrentUnit();//?
		showMoveOverlay();
		enablePlayerControl();//?
		// Who controls menuing? UnitTurnController?
		waitForTurnComplete(); //?
		hideMoveOverlay()
		return;
	}

}


class GameStateController {
	private var _currentFlow:IFlow;
	private var _flowStack:Vector.<IFlow> = new Vector.<IFlow>();

	public function setCurrentFlow(flow:IFlow):void {
		_flowStack.push(flow);
		flow.addEventListener(Event.COMPLETE, flowCompleteHandler);
	}

	private function flowCompleteHandler(evt:Event) {
		if ((evt.target as IFlow) == _currentFlow) {

		}
	}
}